# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

- напишите список операций, которые вы будете производить для остановки запроса пользователя

>1. Получить текущую выполняемую операцию db.currentOp()
>2. Убить её: db.killOp("< opid из п.1 >")

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

>Проблем может быть несколько:
> 1. Поиск/Сортировка без индексов - построить индекс.
> 2. Созданы документы с большими массивами, при изменении документов будет происходить долгая переиндексация - не создавать такие большие документы.
> 

## Задача 2

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
> У нас много ключей, TTL которых истекает в одно время.

 
## Задача 3


Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки

Как вы думаете, почему это начало происходить и как локализовать проблему?
> Если происходит потеря соединения с базой данных во время выполнения запроса, то у нас либо очень долгий запрос, либо очень большой объём данных в результате запроса получается. Либо блокировки возникают.

Какие пути решения данной проблемы вы можете предложить?
> Как быстрое временное решение - проверить параметр connect_timeout и увеличить его до десятков секунд. За это время запрос должен успеть выполниться, а большой объём данных (как результат запроса) будет возвращён клиенту. В обязательном порядке провести EXPLAIN (индексы, объём данных, блокировки) и для оптимизации запроса и либо отправить разработчикам тикет, либо добавить железа на сервере.



## Задача 4

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?
> oom-killer - компонент ядра Linux, контроллирующий память и убивающий процессы для её освобождения в интересах ядра. Процесс выбирается по принципу: убить минимум процессов, освободив максимум памяти. Убивается Постгресс, т.к. он занимает слишком много памяти. Но стоит проверить сервер на наличие и других "прожорливых" процессов, м.б. Постгрес просто попадает под раздачу.

Как бы вы решили данную проблему?

> 1. Версия №1 - "Неверное конфигурирование PostgreSQL". Проверить конфигурационный файл postgresql.conf. Значения разделяемой памяти не должно быть больше 80% доступной (а не общей физической) памяти, значение рабочей памяти, временной и прочих тоже не завышено:
> - shared_buffers
> - work_mem
> - temp_buffres
> - maintenance_work_mem
> - autovacuum_work_mem
> 
> Желательно ещё проверить значение max_connections, может так много и не нужно, а память под буферы резервируется.
>
>2. Запускаем нашу систему так, чтобы на сервере осталось немного свободной памяти. Далее мониторим размеры процессов, м.б. у кого-то будет утечка памяти.
>